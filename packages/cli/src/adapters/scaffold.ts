import * as fs from 'fs/promises'
import * as path from 'path'
import chalk from 'chalk'
import { createChildLogger } from './logger'
import { PrismaProvider } from './scaffold/providers/prisma'
import { SchemaProvider, ModelSchema } from './scaffold/providers/base'

const logger = createChildLogger({ component: 'scaffold' })

// --- Helper Functions ---

/**
 * Check if a Prisma schema file exists in the current project
 */
async function hasPrismaSchema(): Promise<boolean> {
  const possiblePaths = [
    path.join(process.cwd(), 'prisma', 'schema.prisma'),
    path.join(process.cwd(), 'schema.prisma')
  ]

  for (const schemaPath of possiblePaths) {
    try {
      await fs.access(schemaPath)
      return true
    } catch {
      // Continue checking other paths
    }
  }

  return false
}

/**
 * Get available Prisma models from the schema
 */
async function getPrismaModels(): Promise<string[]> {
  try {
    const provider = new PrismaProvider()
    return await provider.listModels()
  } catch (error) {
    logger.debug('Failed to get Prisma models', { error })
    return []
  }
}

function toPascalCase(str: string): string {
  return str.replace(/(^\w|-\w)/g, g => g.replace(/-/, '').toUpperCase())
}

function toCamelCase(str: string): string {
  const pascal = toPascalCase(str)
  return pascal.charAt(0).toLowerCase() + pascal.slice(1)
}

async function writeFile(filePath: string, content: string): Promise<void> {
  const dir = path.dirname(filePath);
  await fs.mkdir(dir, { recursive: true });
  await fs.writeFile(filePath, content, 'utf-8');
}


// --- Schema Provider Factory ---

function getSchemaProvider(providerName: string): SchemaProvider {
  if (providerName.toLowerCase() === 'prisma') {
    return new PrismaProvider();
  }
  // Future providers like Drizzle would be added here
  // else if (providerName.toLowerCase() === 'drizzle') {
  //   return new DrizzleProvider();
  // }
  throw new Error(`Unsupported schema provider: ${providerName}`);
}

// --- CRUD Template Generators ---

function generateCrudInterfacesTemplate(model: ModelSchema, featureName?: string): string {
  const modelNamePascal = toPascalCase(model.name);

  // Filter out relation fields — only scalar fields go into Zod schemas
  const scalarFields = model.fields.filter(field => !field.isRelation);

  // Fields eligible for creation (exclude id and auto-generated like createdAt, updatedAt)
  const createFields = scalarFields.filter(f => !f.isId && !f.isAutoGenerated);

  const createZodFields = createFields.map(field => {
    let zodType = fieldToZodType(field);
    // Fields with @default can be omitted (use .optional()), but are NOT nullable
    if (field.hasDefault) {
      zodType += '.optional()';
    }
    return `    ${field.name}: ${zodType},`;
  }).join('\n');

  const updateZodFields = createFields.map(field => {
    let zodType = fieldToZodType(field);
    zodType += '.optional()';
    return `    ${field.name}: ${zodType},`;
  }).join('\n');

  return `import { z } from "zod";

/**
 * @description Zod schema for creating a new ${modelNamePascal}.
 */
export const Create${modelNamePascal}BodySchema = z.object({
${createZodFields}
});

/**
 * @description Zod schema for updating an existing ${modelNamePascal}.
 */
export const Update${modelNamePascal}BodySchema = z.object({
${updateZodFields}
});

/**
 * @description Type for Create${modelNamePascal}BodySchema.
 */
export type Create${modelNamePascal}Body = z.infer<typeof Create${modelNamePascal}BodySchema>;

/**
 * @description Type for Update${modelNamePascal}BodySchema.
 */
export type Update${modelNamePascal}Body = z.infer<typeof Update${modelNamePascal}BodySchema>;
`;
}

function fieldToZodType(field: { type: string; isNullable: boolean; name?: string }): string {
  let zodType: string;
  switch (field.type) {
    case 'string':
    case 'bigint':
      zodType = 'z.string()';
      break;
    case 'number':
      zodType = 'z.number()';
      break;
    case 'boolean':
      zodType = 'z.boolean()';
      break;
    case 'Date':
      zodType = 'z.date()';
      break;
    default:
      zodType = `z.any()`;
  }
  if (field.isNullable) {
    zodType += '.nullable()';
  }
  return zodType;
}


function generateCrudRepositoryTemplate(model: ModelSchema, featureName?: string): string {
  const modelNameCamel = toCamelCase(model.name);
  const modelNamePascal = toPascalCase(model.name);
  const idField = model.fields.find(f => f.isId);
  if (!idField) throw new Error(`Model ${model.name} has no ID field.`);

  // Detect FK fields for relational syntax
  const fkFields = model.fields.filter(f => f.isForeignKey && !f.isId && !f.isAutoGenerated);
  const hasFkFields = fkFields.length > 0;

  // Build create method body
  let createBody: string;
  if (hasFkFields) {
    const destructure = fkFields.map(f => f.name).join(', ');
    const connects = fkFields.map(f =>
      `                ${f.relationFieldName}: { connect: { id: ${f.name} } },`
    ).join('\n');
    createBody = `        const { ${destructure}, ...rest } = data;
        return this.db.${modelNameCamel}.create({
            data: {
                ...rest,
${connects}
            },
        });`;
  } else {
    createBody = `        return this.db.${modelNameCamel}.create({
            data,
        });`;
  }

  // Build update method body
  let updateBody: string;
  if (hasFkFields) {
    const destructure = fkFields.map(f => f.name).join(', ');
    const connects = fkFields.map(f =>
      `                ...(${f.name} && { ${f.relationFieldName}: { connect: { id: ${f.name} } } }),`
    ).join('\n');
    updateBody = `        const { ${destructure}, ...rest } = data;
        return this.db.${modelNameCamel}.update({
            where: { id },
            data: {
                ...rest,
${connects}
            },
        });`;
  } else {
    updateBody = `        return this.db.${modelNameCamel}.update({
            where: { id },
            data,
        });`;
  }

  return `import { PrismaClient, ${modelNamePascal} } from "@prisma/client";
import { Create${modelNamePascal}Body, Update${modelNamePascal}Body } from "../${featureName}.interfaces";

/**
 * @class ${modelNamePascal}Repository
 * @description Centralizes all database operations for the ${modelNamePascal} entity using Prisma.
 */
export class ${modelNamePascal}Repository {
    private db: PrismaClient;

    /**
     * @constructor
     * @param {PrismaClient} db - The Prisma database client.
     */
    constructor(db: PrismaClient) {
        this.db = db;
    }

    /**
     * @method list
     * @description Retrieves a list of all ${modelNamePascal.toLowerCase()}s.
     * @returns {Promise<${modelNamePascal}[]>} A promise that resolves to an array of ${modelNamePascal.toLowerCase()}s.
     */
    async list(): Promise<${modelNamePascal}[]> {
        return this.db.${modelNameCamel}.findMany({
            orderBy: { id: "asc" },
        });
    }

    /**
     * @method getById
     * @description Retrieves a single ${modelNamePascal.toLowerCase()} by their unique ID.
     * @param {${idField.type}} id - The unique ID of the ${modelNamePascal.toLowerCase()}.
     * @returns {Promise<${modelNamePascal} | null>} A promise that resolves to the ${modelNamePascal.toLowerCase()} if found, or null otherwise.
     */
    async getById(id: ${idField.type}): Promise<${modelNamePascal} | null> {
        return this.db.${modelNameCamel}.findUnique({
            where: { id },
        });
    }

    /**
     * @method create
     * @description Creates a new ${modelNamePascal.toLowerCase()} record in the database.
     * @param {Create${modelNamePascal}Body} data - The data for the new ${modelNamePascal.toLowerCase()}.
     * @returns {Promise<${modelNamePascal}>} A promise that resolves to the created ${modelNamePascal.toLowerCase()}.
     */
    async create(data: Create${modelNamePascal}Body): Promise<${modelNamePascal}> {
${createBody}
    }

    /**
     * @method update
     * @description Updates an existing ${modelNamePascal.toLowerCase()} record in the database.
     * @param {${idField.type}} id - The ID of the ${modelNamePascal.toLowerCase()} to update.
     * @param {Update${modelNamePascal}Body} data - The data to update.
     * @returns {Promise<${modelNamePascal}>} A promise that resolves to the updated ${modelNamePascal.toLowerCase()}.
     */
    async update(id: ${idField.type}, data: Update${modelNamePascal}Body): Promise<${modelNamePascal}> {
${updateBody}
    }

    /**
     * @method delete
     * @description Deletes a ${modelNamePascal.toLowerCase()} record from the database.
     * @param {${idField.type}} id - The ID of the ${modelNamePascal.toLowerCase()} to delete.
     * @returns {Promise<${modelNamePascal}>} A promise that resolves to the deleted ${modelNamePascal.toLowerCase()}.
     */
    async delete(id: ${idField.type}): Promise<${modelNamePascal}> {
        return this.db.${modelNameCamel}.delete({
            where: { id },
        });
    }
}
`;
}

function generateCrudProcedureTemplate(model: ModelSchema, featureName?: string): string {
  const modelNameCamel = toCamelCase(model.name);
  const modelNamePascal = toPascalCase(model.name);
  const idField = model.fields.find(f => f.isId);
  if (!idField) throw new Error(`Model ${model.name} has no ID field.`);

  // Detect FK fields for relational syntax
  const fkFields = model.fields.filter(f => f.isForeignKey && !f.isId && !f.isAutoGenerated);
  const hasFkFields = fkFields.length > 0;

  // Build create body
  let procCreateBody: string;
  if (hasFkFields) {
    const destructure = fkFields.map(f => f.name).join(', ');
    const connects = fkFields.map(f =>
      `                            ${f.relationFieldName}: { connect: { id: ${f.name} } },`
    ).join('\n');
    procCreateBody = `                    // Business Logic: Create a new ${modelNamePascal.toLowerCase()} using Prisma.
                    const { ${destructure}, ...rest } = data;
                    const ${modelNameCamel} = await context.database.${modelNameCamel}.create({
                        data: {
                            ...rest,
${connects}
                        },
                    });`;
  } else {
    procCreateBody = `                    // Business Logic: Create a new ${modelNamePascal.toLowerCase()} using Prisma.
                    const ${modelNameCamel} = await context.database.${modelNameCamel}.create({
                        data,
                    });`;
  }

  // Build update body
  let procUpdateBody: string;
  if (hasFkFields) {
    const destructure = fkFields.map(f => f.name).join(', ');
    const connects = fkFields.map(f =>
      `                            ...(${f.name} && { ${f.relationFieldName}: { connect: { id: ${f.name} } } }),`
    ).join('\n');
    procUpdateBody = `                    // Business Logic: Update the ${modelNamePascal.toLowerCase()} using Prisma.
                    const { ${destructure}, ...rest } = data;
                    const ${modelNameCamel} = await context.database.${modelNameCamel}.update({
                        where: { id },
                        data: {
                            ...rest,
${connects}
                        },
                    });`;
  } else {
    procUpdateBody = `                    // Business Logic: Update the ${modelNamePascal.toLowerCase()} using Prisma.
                    const ${modelNameCamel} = await context.database.${modelNameCamel}.update({
                        where: { id },
                        data,
                    });`;
  }

  return `import { zyntra } from "@/zyntra";
import { ${modelNamePascal} } from "@prisma/client";
import { Create${modelNamePascal}Body, Update${modelNamePascal}Body } from "../${featureName}.interfaces";

/**
 * @procedure ${modelNamePascal}Procedure
 * @description Procedure for managing ${modelNamePascal.toLowerCase()} operations and data processing.
 *
 * This procedure provides the business logic layer for ${modelNamePascal.toLowerCase()} management, handling
 * the complete lifecycle of ${modelNamePascal.toLowerCase()} data including creation, updates, and deletion.
 * It injects ${modelNamePascal.toLowerCase()} management methods into the Zyntra context, making them
 * available to controllers and other parts of the application.
 *
 * @example
 * \`\`\`typescript
 * // Used in controllers
 * const records = await context.${modelNameCamel}.findMany()
 * const record = await context.${modelNameCamel}.findUnique("some-id")
 * \`\`\`
 */
export const ${modelNameCamel}Procedure = zyntra.procedure({
    name: '${modelNamePascal}Procedure',
    handler: (_, { context }) => {
        // Context Extension: Return the repository instance in hierarchical structure for consistency.
        return {
            ${modelNameCamel}: {
                /**
                 * @method findMany
                 * @description Retrieves all ${modelNamePascal.toLowerCase()}s.
                 *
                 * @returns {Promise<${modelNamePascal}[]>} Array of ${modelNamePascal.toLowerCase()} objects
                 * @throws {Error} When database query fails
                 */
                findMany: async (): Promise<${modelNamePascal}[]> => {
                    // Business Logic: Retrieve all ${modelNamePascal.toLowerCase()}s using Prisma.
                    return context.database.${modelNameCamel}.findMany({
                        orderBy: { id: "asc" },
                    });
                },

                /**
                 * @method findUnique
                 * @description Retrieves a specific ${modelNamePascal.toLowerCase()} by ID.
                 *
                 * @param {${idField.type}} id - Unique identifier of the ${modelNamePascal.toLowerCase()} to retrieve
                 * @returns {Promise<${modelNamePascal} | null>} ${modelNamePascal} object if found, null otherwise
                 * @throws {Error} When database query fails
                 */
                findUnique: async (id: ${idField.type}): Promise<${modelNamePascal} | null> => {
                    // Business Logic: Retrieve the ${modelNamePascal.toLowerCase()} using Prisma.
                    return context.database.${modelNameCamel}.findUnique({
                        where: { id },
                    });
                },

                /**
                 * @method create
                 * @description Creates a new ${modelNamePascal.toLowerCase()}.
                 *
                 * @param {Create${modelNamePascal}Body} data - ${modelNamePascal} creation data
                 * @returns {Promise<${modelNamePascal}>} The newly created ${modelNamePascal.toLowerCase()} object
                 * @throws {Error} When database operation fails
                 */
                create: async (data: Create${modelNamePascal}Body): Promise<${modelNamePascal}> => {
${procCreateBody}

                    // Response: Return the newly created ${modelNamePascal.toLowerCase()}
                    return ${modelNameCamel};
                },

                /**
                 * @method update
                 * @description Updates an existing ${modelNamePascal.toLowerCase()}.
                 *
                 * @param {${idField.type}} id - Unique identifier of the ${modelNamePascal.toLowerCase()} to update
                 * @param {Update${modelNamePascal}Body} data - Updated ${modelNamePascal.toLowerCase()} data
                 * @returns {Promise<${modelNamePascal}>} The updated ${modelNamePascal.toLowerCase()} object
                 * @throws {Error} When ${modelNamePascal.toLowerCase()} is not found or database operation fails
                 */
                update: async (id: ${idField.type}, data: Update${modelNamePascal}Body): Promise<${modelNamePascal}> => {
                    // Business Rule: Check if ${modelNamePascal.toLowerCase()} exists before updating.
                    const ${modelNameCamel}Exists = await context.database.${modelNameCamel}.findUnique({
                        where: { id },
                    });

                    if (!${modelNameCamel}Exists) {
                        throw new Error('${modelNamePascal} not found');
                    }

${procUpdateBody}

                    // Response: Return the updated ${modelNamePascal.toLowerCase()}
                    return ${modelNameCamel};
                },

                /**
                 * @method delete
                 * @description Permanently deletes a ${modelNamePascal.toLowerCase()}.
                 *
                 * @param {${idField.type}} id - Unique identifier of the ${modelNamePascal.toLowerCase()} to delete
                 * @returns {Promise<${modelNamePascal}>} The deleted ${modelNamePascal.toLowerCase()} object
                 * @throws {Error} When ${modelNamePascal.toLowerCase()} is not found or database operation fails
                 */
                delete: async (id: ${idField.type}): Promise<${modelNamePascal}> => {
                    // Business Logic: Delete the ${modelNamePascal.toLowerCase()} using Prisma.
                    const ${modelNameCamel} = await context.database.${modelNameCamel}.delete({
                        where: { id },
                    });

                    // Response: Return the deleted ${modelNamePascal.toLowerCase()}
                    return ${modelNameCamel};
                },
            },
        };
    },
});
`;
}

function generateCrudControllerTemplate(model: ModelSchema, featureName?: string): string {
  const modelNameCamel = toCamelCase(model.name);
  const modelNamePascal = toPascalCase(model.name);

  const idField = model.fields.find(f => f.isId);
  if (!idField) throw new Error(`Model ${model.name} has no ID field.`);

  return `import { zyntra } from "@/zyntra";
import { Create${modelNamePascal}BodySchema, Update${modelNamePascal}BodySchema } from "../${featureName}.interfaces";
import { ${modelNameCamel}Procedure } from "../procedures/${featureName}.procedure";

/**
 * @const ${modelNameCamel}Controller
 * @description
 * Controller for managing ${modelNamePascal.toLowerCase()}-related operations, including listing, creating,
 * updating, and deleting ${modelNamePascal.toLowerCase()}s.
 */
export const ${modelNameCamel}Controller = zyntra.controller({
    name: "${modelNameCamel}",
    path: "/${modelNameCamel}",
    description: "${modelNamePascal} management endpoints for handling ${modelNamePascal.toLowerCase()} data.",
    actions: {
        /**
         * @action list
         * @description Retrieves a list of all registered ${modelNamePascal.toLowerCase()}s.
         */
        list: zyntra.query({
            name: "List",
            description: "List all ${modelNamePascal.toLowerCase()}s currently registered in the system.",
            path: "",
            use: [${modelNameCamel}Procedure()],
            handler: async ({ response, context }) => {
                // Business Logic: Use the injected ${modelNamePascal.toLowerCase()} methods to fetch all records.
                const records = await context.${modelNameCamel}.findMany();

                // Response: Return the list of ${modelNamePascal.toLowerCase()}s with a 200 OK status.
                return response.success(records);
            },
        }),

        /**
         * @action getById
         * @description Retrieves a specific ${modelNamePascal.toLowerCase()} by their unique ID.
         */
        getById: zyntra.query({
            name: "GetById",
            description: "Fetch a single ${modelNamePascal.toLowerCase()}'s details using their unique identifier.",
            path: ":id" as const,
            use: [${modelNameCamel}Procedure()],
            handler: async ({ request, response, context }) => {
                // Observation: Extract the ${modelNamePascal.toLowerCase()} ID from the request parameters.
                const { id } = request.params;

                // Business Logic: Attempt to find the ${modelNamePascal.toLowerCase()} by ID via the injected methods.
                const record = await context.${modelNameCamel}.findUnique(id);

                // Business Rule: If a ${modelNamePascal.toLowerCase()} is not found, return a 404 Not Found response.
                if (!record) {
                    return response.notFound("${modelNamePascal} not found.");
                }

                // Response: Return the found ${modelNamePascal.toLowerCase()} with a 200 OK status.
                return response.success(record);
            },
        }),

        /**
         * @action create
         * @description Creates a new ${modelNamePascal.toLowerCase()} record.
         */
        create: zyntra.mutation({
            name: "Create",
            description: "Register a new ${modelNamePascal.toLowerCase()} in the system.",
            path: "",
            method: "POST",
            body: Create${modelNamePascal}BodySchema,
            use: [${modelNameCamel}Procedure()],
            handler: async ({ request, response, context }) => {
                // Observation: Extract creation data from the validated request body.
                const data = request.body;

                // Business Logic: Create the new ${modelNamePascal.toLowerCase()} record using the repository.
                const record = await context.${modelNameCamel}.create(data);

                // Response: Return the newly created ${modelNamePascal.toLowerCase()} with a 201 Created status.
                return response.created(record);
            },
        }),

        /**
         * @action update
         * @description Updates an existing ${modelNamePascal.toLowerCase()}'s information.
         */
        update: zyntra.mutation({
            name: "Update",
            description: "Modify an existing ${modelNamePascal.toLowerCase()}'s details.",
            path: ":id" as const,
            method: "PUT",
            body: Update${modelNamePascal}BodySchema,
            use: [${modelNameCamel}Procedure()],
            handler: async ({ request, response, context }) => {
                // Observation: Extract ${modelNamePascal.toLowerCase()} ID and update data.
                const { id } = request.params;
                const data = request.body;

                // Business Logic: Attempt to update the ${modelNamePascal.toLowerCase()} record via the injected methods.
                try {
                    const record = await context.${modelNameCamel}.update(id, data);
                    // Response: Return the updated ${modelNamePascal.toLowerCase()} with a 200 OK status.
                    return response.success(record);
                } catch (error) {
                    // Business Rule: Handle cases where the ${modelNamePascal.toLowerCase()} might not exist or update fails.
                    return response.notFound("${modelNamePascal} not found or update failed.");
                }
            },
        }),

        /**
         * @action delete
         * @description Removes a ${modelNamePascal.toLowerCase()} from the system.
         */
        delete: zyntra.mutation({
            name: "Delete",
            description: "Permanently delete a ${modelNamePascal.toLowerCase()} from the system.",
            path: ":id" as const,
            method: "DELETE",
            use: [${modelNameCamel}Procedure()],
            handler: async ({ request, response, context }) => {
                // Observation: Extract the ${modelNamePascal.toLowerCase()} ID to be deleted.
                const { id } = request.params;

                // Business Logic: Use the injected methods to delete the ${modelNamePascal.toLowerCase()} record.
                try {
                    await context.${modelNameCamel}.delete(id);
                    // Response: Return a 204 No Content status for successful deletion.
                    return response.noContent();
                } catch (error) {
                    // Business Rule: Handle cases where deletion fails (e.g., ${modelNamePascal.toLowerCase()} not found).
                    return response.notFound("${modelNamePascal} not found or deletion failed.");
                }
            },
        }),
    },
});
`;
}

function generateCrudIndexTemplate(featureName: string): string {
  return `export * from './controllers/${featureName}.controller'
export * from './procedures/${featureName}.procedure'
export * from './repositories/${featureName}.repository'
export * from './${featureName}.interfaces'
`;
}


// --- Empty Feature Template Generators ---

function generateEmptyControllerTemplate(featureName: string): string {
  const controllerName = `${featureName.toLowerCase()}Controller`
  return `import { zyntra } from '@/zyntra'
import { z } from 'zod'

export const ${controllerName} = zyntra.controller({
  name: '${featureName}',
  path: '/${featureName}',
  actions: {
    hello: zyntra.query({
      path: 'hello',
      handler: async ({ response }) => {
        return response.success({ message: 'Hello from ${featureName}!' })
      },
    }),
  },
})
`
}

function generateEmptyInterfacesTemplate(featureName: string): string {
  return `// Zod schemas and TypeScript types for the ${featureName} feature.
`
}

function generateEmptyIndexTemplate(featureName: string): string {
  return `export * from './controllers/${featureName}.controller'
`
}

// --- Main Scaffolding Logic ---

async function scaffoldEmptyFeature(featureName: string, featureDir: string) {
  logger.info(`Creating empty feature '${featureName}'...`)

  try {
    await fs.mkdir(path.join(featureDir, 'controllers'), { recursive: true })
    await fs.mkdir(path.join(featureDir, 'procedures'), { recursive: true })

    await writeFile(
      path.join(featureDir, 'controllers', `${featureName}.controller.ts`),
      generateEmptyControllerTemplate(featureName)
    )
    await writeFile(
      path.join(featureDir, `${featureName}.interfaces.ts`),
      generateEmptyInterfacesTemplate(featureName)
    )
    await writeFile(
      path.join(featureDir, 'index.ts'),
      generateEmptyIndexTemplate(featureName)
    )
    logger.success(`Scaffolded empty feature '${featureName}'`)
  } catch (error) {
    logger.error(`Failed to create empty feature '${featureName}'`)
    throw error
  }
}


async function scaffoldFeatureFromSchema(featureName: string, schemaString: string, featureDir: string) {
  logger.info(`Scaffolding feature '${featureName}' from schema...`)

  try {
    const [providerName, modelName] = schemaString.split(':')
    if (!providerName || !modelName) {
      throw new Error('Invalid schema format. Expected `provider:ModelName` (e.g., `prisma:User`).')
    }

    const provider = getSchemaProvider(providerName)
    const model = await provider.getModel(modelName)

    if (!model) {
      throw new Error(`Model '${modelName}' not found using provider '${providerName}'.`)
    }

    logger.info('Generating files from model schema...')

    await fs.mkdir(path.join(featureDir, 'controllers'), { recursive: true })
    await fs.mkdir(path.join(featureDir, 'procedures'), { recursive: true })
    await fs.mkdir(path.join(featureDir, 'repositories'), { recursive: true })

    await writeFile(
      path.join(featureDir, `${featureName}.interfaces.ts`),
      generateCrudInterfacesTemplate(model, featureName)
    )
    await writeFile(
      path.join(featureDir, 'repositories', `${featureName}.repository.ts`),
      generateCrudRepositoryTemplate(model, featureName)
    )
    await writeFile(
      path.join(featureDir, 'procedures', `${featureName}.procedure.ts`),
      generateCrudProcedureTemplate(model, featureName)
    )
    await writeFile(
      path.join(featureDir, 'controllers', `${featureName}.controller.ts`),
      generateCrudControllerTemplate(model, featureName)
    )
    await writeFile(
      path.join(featureDir, 'index.ts'),
      generateCrudIndexTemplate(featureName)
    )

    logger.success(`Successfully scaffolded feature '${featureName}' from '${modelName}' model.`)
    console.log(chalk.cyan(`\n✅ Next step: Register the '${toCamelCase(featureName)}Controller' in 'src/zyntra.router.ts'`))

  } catch (error) {
    logger.error(`Failed to scaffold feature from schema`)
    throw error
  }
}


export async function handleGenerateFeature(
  name: string | undefined,
  options: { schema?: string } = {}
): Promise<void> {
  let featureName = name

  // Interactive wizard when no name is provided
  if (!featureName) {
    const prompts = await import('prompts')

    // Check if Prisma schema is available
    const hasPrisma = await hasPrismaSchema()
    const prismaModels = hasPrisma ? await getPrismaModels() : []

    const questions: any[] = [
      {
        type: 'text',
        name: 'featureName',
        message: 'What is the name of your feature?',
        validate: (input: string) => {
          if (!input.trim()) {
            return 'Feature name is required'
          }
          if (!/^[a-zA-Z][a-zA-Z0-9-_]*$/.test(input)) {
            return 'Feature name must start with a letter and contain only letters, numbers, hyphens, and underscores'
          }
          return true
        }
      }
    ]

    // Add Prisma model selection if available
    if (hasPrisma && prismaModels.length > 0) {
      questions.push({
        type: 'select',
        name: 'useModel',
        message: 'Would you like to generate CRUD operations from a Prisma model?',
        choices: [
          { title: 'No, create an empty feature', value: 'none' },
          { title: 'Yes, select a Prisma model', value: 'select' }
        ],
        initial: 0
      })

      questions.push({
        type: (prev: string) => prev === 'select' ? 'select' : null,
        name: 'selectedModel',
        message: 'Which Prisma model would you like to use?',
        choices: prismaModels.map(model => ({ title: model, value: model }))
      })
    }

    const response = await prompts.default(questions)

    if (!response.featureName) {
      logger.error('Feature name is required')
      process.exit(1)
    }

    featureName = response.featureName

    // If user selected a Prisma model, set it as the schema option with proper format
    if (response.useModel === 'select' && response.selectedModel) {
      options.schema = `prisma:${response.selectedModel}`
    }
  }

  // At this point, featureName is guaranteed to be defined
  const normalizedName = featureName!.toLowerCase()
  const featureDir = path.join(process.cwd(), 'src', 'features', normalizedName)

  logger.info(`Scaffolding feature: ${chalk.cyan(normalizedName)}`)

  try {
    await fs.access(featureDir)
    logger.error(`Feature '${normalizedName}' already exists.`)
    console.error(chalk.red(`✗ Feature '${normalizedName}' already exists at ${path.relative(process.cwd(), featureDir)}`))
    return
  } catch (error) {
    // Directory does not exist, which is what we want.
  }

  if (options.schema) {
    await scaffoldFeatureFromSchema(normalizedName, options.schema, featureDir)
  } else {
    await scaffoldEmptyFeature(normalizedName, featureDir)
  }
}

// Stub for future commands
export async function handleGenerateController(name: string, feature: string): Promise<void> {
  logger.warn(`'generate controller' is not yet fully implemented. Use 'generate feature --schema' instead.`)
}
export async function handleGenerateProcedure(name: string, feature: string): Promise<void> {
  logger.warn(`'generate procedure' is not yet fully implemented. Use 'generate feature --schema' instead.`)
}
