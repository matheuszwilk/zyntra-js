---
title: Comparison
description: A comprehensive comparison of ZyntraJS with popular TypeScript API frameworks including tRPC, Next.js Server Actions, Express, and Fastify.
---

## Overview

Choosing the right framework is crucial for your project's success. This guide compares **ZyntraJS** with popular alternatives to help you make an informed decision.

<Callout type="info" title="Fair Comparison">
  This comparison aims to be fair and objective. Each framework has its strengths, and the "best" choice depends on your specific needs.
</Callout>

---

## Quick Comparison Table

| Feature | ZyntraJS | tRPC | Next.js SA | Express | Fastify |
|---------|------------|------|------------|---------|---------|
| **Type Safety** | âœ… End-to-end | âœ… End-to-end | âš ï¸ Partial | âŒ Manual | âŒ Manual |
| **Code Generation** | âŒ Not needed | âŒ Not needed | âŒ Not needed | âŒ Not needed | âŒ Not needed |
| **Standard HTTP** | âœ… Full | âš ï¸ RPC only | âš ï¸ Limited | âœ… Full | âœ… Full |
| **Framework Agnostic** | âœ… Yes | âš ï¸ Mostly | âŒ Next.js only | âœ… Yes | âœ… Yes |
| **React Hooks** | âœ… Built-in | âœ… Adapter | âœ… Built-in | âŒ Manual | âŒ Manual |
| **OpenAPI** | âœ… Auto | âŒ External | âŒ No | âš ï¸ Manual | âš ï¸ Manual |
| **Real-time** | âœ… SSE/WS | âš ï¸ Subscriptions | âŒ Limited | âš ï¸ Manual | âš ï¸ Manual |
| **Middleware** | âœ… Procedures | âœ… Yes | âŒ Limited | âœ… Yes | âœ… Yes |
| **Background Jobs** | âœ… Built-in | âŒ External | âŒ External | âŒ External | âŒ External |
| **Telemetry** | âœ… Built-in | âŒ External | âŒ External | âŒ External | âŒ External |
| **Learning Curve** | ğŸŸ¢ Low | ğŸŸ¢ Low | ğŸŸ¢ Low | ğŸŸ¡ Medium | ğŸŸ¡ Medium |
| **Performance** | âš¡ Fast | âš¡ Fast | âš¡ Fast | âš¡ Fast | âš¡âš¡ Fastest |

---

## ZyntraJS vs tRPC

### Overview

Both provide **end-to-end type safety** without code generation. If you like tRPC, you'll feel at home with ZyntraJS.

### Feature Comparison

| Feature | ZyntraJS | tRPC |
|---------|------------|------|
| Type Safety | âœ… Full end-to-end | âœ… Full end-to-end |
| HTTP Methods | âœ… GET, POST, PUT, DELETE, PATCH | âš ï¸ RPC only |
| REST Support | âœ… Standard REST endpoints | âŒ Not RESTful |
| Framework Support | âœ… Next.js, Vite, Express, Bun, Deno | âš ï¸ Primarily Next.js |
| React Hooks | âœ… Built-in | âœ… Via @trpc/react-query |
| OpenAPI Docs | âœ… Auto-generated | âŒ Third-party tools |
| Background Jobs | âœ… Built-in (BullMQ) | âŒ External library |
| Caching/Pub-Sub | âœ… Built-in (Redis) | âŒ External library |
| Telemetry | âœ… Built-in (OpenTelemetry) | âŒ External library |
| Non-TS Clients | âœ… Works with any HTTP client | âš ï¸ TypeScript only |

### Code Comparison

<Tabs items={['ZyntraJS', 'tRPC']}>
  <Tab value="ZyntraJS">
    ```typescript
    // Define API with standard HTTP
    const userController = zyntra.controller({
      name: 'Users',
      description: 'Manage user accounts and profiles',
      path: '/users',
      actions: {
        getById: zyntra.query({
          name: 'Get User by ID',
          description: 'Retrieve a specific user by their ID',
          path: '/:id' as const,
          handler: async ({ request, response }) => {
            const user = await db.users.findUnique({
              where: { id: request.params.id }
            });
            return response.success({ user });
          }
        }),
        create: zyntra.mutation({
          name: 'Create User',
          description: 'Create a new user account',
          path: '/',
          method: 'POST',
          body: z.object({
            name: z.string(),
            email: z.string().email()
          }),
          handler: async ({ request, response }) => {
            const user = await db.users.create({ 
              data: request.body 
            });
            return response.created({ user });
          }
        })
      }
    });
    
    // Client usage
    const { data } = await client.users.getById.query({ 
      params: { id: '123' } 
    });
    
    // âœ… Also works with curl, Postman, etc.
    // GET /api/v1/users/123
    ```
  </Tab>
  
  <Tab value="tRPC">
    ```typescript
    // Define API with RPC
    const userRouter = t.router({
      getById: t.procedure
        .input(z.object({ id: z.string() }))
        .query(async ({ input }) => {
          const user = await db.users.findUnique({ 
            where: { id: input.id } 
          });
          return { user };
        }),
      create: t.procedure
        .input(z.object({
          name: z.string(),
          email: z.string().email()
        }))
        .mutation(async ({ input }) => {
          const user = await db.users.create({ 
            data: input 
          });
          return { user };
        })
    });
    
    // Client usage
    const data = await trpc.users.getById.query({ id: '123' });
    
    // âš ï¸ Only works with TypeScript clients
    // Not standard REST
    ```
  </Tab>
</Tabs>

### When to Choose tRPC

<Cards>
  <Card title="Next.js Only">
    You're building exclusively for Next.js
  </Card>
  <Card title="No REST Needed">
    You don't need standard REST endpoints
  </Card>
  <Card title="No External Clients">
    Only TypeScript clients will consume your API
  </Card>
</Cards>

### When to Choose ZyntraJS

<Cards>
  <Card title="Standard HTTP">
    You need REST endpoints for external clients
  </Card>
  <Card title="Framework Flexibility">
    You want to work with Vite, Express, Bun, etc.
  </Card>
  <Card title="Rich Ecosystem">
    You need jobs, caching, telemetry built-in
  </Card>
  <Card title="OpenAPI Docs">
    You want auto-generated API documentation
  </Card>
</Cards>

---

## ZyntraJS vs Next.js Server Actions

### Overview

Both provide type-safe client-server communication in React, but with very different approaches and capabilities.

### Feature Comparison

| Feature | ZyntraJS | Next.js Server Actions |
|---------|------------|------------------------|
| Type Safety | âœ… Full inference | âš ï¸ Partial (FormData casting) |
| HTTP Methods | âœ… All methods | âŒ POST only |
| REST Endpoints | âœ… Standard REST | âŒ None |
| Framework Support | âœ… Framework agnostic | âŒ Next.js only |
| External Clients | âœ… Any HTTP client | âŒ Next.js only |
| Real-time (SSE) | âœ… Built-in | âŒ Limited |
| WebSockets | âœ… Supported | âŒ Not supported |
| Webhooks | âœ… Standard routes | âŒ Not suitable |
| Validation | âœ… Zod/Valibot schemas | âš ï¸ Manual |
| Testing | âœ… Server-side caller | âš ï¸ Full Next.js context needed |

### Code Comparison

<Tabs items={['ZyntraJS', 'Server Actions']}>
  <Tab value="ZyntraJS">
    ```typescript
    // Server: Type-safe with validation
    const createUser = zyntra.mutation({
      path: '/users',
      method: 'POST',
      body: z.object({
        name: z.string().min(2),
        email: z.string().email()
      }),
      handler: async ({ request, response }) => {
        // âœ… request.body is fully typed!
        const user = await db.users.create({ 
          data: request.body 
        });
        return response.created({ user });
      }
    });
    
    // Client: Fully typed
    const { data } = await client.users.create.mutate({
      body: { name: 'John', email: 'john@example.com' }
    });
    // âœ… data.user is fully typed!
    
    // âœ… Also works with external clients
    // POST /api/v1/users
    ```
  </Tab>
  
  <Tab value="Server Actions">
    ```typescript
    // Server: Manual type casting
    'use server'
    
    async function createUser(formData: FormData) {
      // âš ï¸ Manual casting and validation
      const name = formData.get('name') as string;
      const email = formData.get('email') as string;
      
      // Manual validation
      if (!name || name.length < 2) {
        throw new Error('Name too short');
      }
      
      const user = await db.users.create({ 
        data: { name, email } 
      });
      return user;
    }
    
    // Client: Limited type inference
    const user = await createUser(formData);
    // âš ï¸ Type not automatically inferred
    
    // âŒ Can't call from external clients
    // âŒ No REST endpoint
    ```
  </Tab>
</Tabs>

### When to Choose Server Actions

<Cards>
  <Card title="Next.js Exclusive">
    Building only for Next.js with RSC
  </Card>
  <Card title="Simple Forms">
    Primary use case is form submissions
  </Card>
  <Card title="No External API">
    Don't need external clients or webhooks
  </Card>
</Cards>

### When to Choose ZyntraJS

<Cards>
  <Card title="REST API">
    Need standard REST endpoints
  </Card>
  <Card title="Framework Agnostic">
    Want to use Vite, Remix, or other frameworks
  </Card>
  <Card title="External Clients">
    Mobile apps, webhooks, third-party integrations
  </Card>
  <Card title="Real-time">
    Need SSE, WebSockets, or Pub/Sub
  </Card>
</Cards>

---

## ZyntraJS vs Express.js

### Overview

Express is the most popular Node.js framework, while ZyntraJS is a modern TypeScript-first alternative with built-in type safety.

### Feature Comparison

| Feature | ZyntraJS | Express.js |
|---------|------------|------------|
| Type Safety | âœ… Automatic inference | âŒ Manual TypeScript |
| Validation | âœ… Built-in (Zod/Valibot) | âŒ External (express-validator) |
| Client Generation | âœ… Automatic | âŒ Manual |
| React Hooks | âœ… Built-in | âŒ Manual implementation |
| OpenAPI Docs | âœ… Auto-generated | âš ï¸ Manual (Swagger) |
| Background Jobs | âœ… Built-in | âŒ External library |
| Telemetry | âœ… Built-in | âŒ External (Morgan, etc.) |
| Ecosystem | ğŸŸ¡ Growing | âš¡ Massive |
| Maturity | ğŸŸ¡ New | âš¡âš¡âš¡ Very mature |
| Learning Curve | ğŸŸ¢ Low | ğŸŸ¢ Low |

### Code Comparison

<Tabs items={['ZyntraJS', 'Express.js']}>
  <Tab value="ZyntraJS">
    ```typescript
    // Route with automatic validation & typing
    const createUser = zyntra.mutation({
      path: '/users',
      method: 'POST',
      body: z.object({
        name: z.string().min(2),
        email: z.string().email(),
        age: z.number().min(18)
      }),
      handler: async ({ request, response }) => {
        // âœ… request.body is validated and typed
        const { name, email, age } = request.body;
        
        const user = await db.users.create({ 
          data: { name, email, age } 
        });
        
        return response.created({ user });
      }
    });
    
    // Client: Automatic type-safe hooks
    const { mutate, isLoading } = client.users.create.useMutation();
    
    await mutate({ 
      body: { name: 'John', email: 'john@example.com', age: 25 } 
    });
    ```
  </Tab>
  
  <Tab value="Express.js">
    ```typescript
    import { body, validationResult } from 'express-validator';
    
    // Route with manual validation
    app.post('/users',
      // Manual validation rules
      body('name').isString().isLength({ min: 2 }),
      body('email').isEmail(),
      body('age').isInt({ min: 18 }),
      async (req, res) => {
        // Manual error checking
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
          return res.status(400).json({ errors: errors.array() });
        }
        
        // âš ï¸ Manual type casting
        const { name, email, age } = req.body as {
          name: string;
          email: string;
          age: number;
        };
        
        const user = await db.users.create({ 
          data: { name, email, age } 
        });
        
        res.status(201).json({ user });
      }
    );
    
    // Client: Manual fetch
    const response = await fetch('/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'John', email: 'john@example.com', age: 25 })
    });
    
    const data = await response.json() as { user: User };
    ```
  </Tab>
</Tabs>

### When to Choose Express

<Cards>
  <Card title="Huge Ecosystem">
    Need access to thousands of Express plugins
  </Card>
  <Card title="Team Experience">
    Team is already experienced with Express
  </Card>
  <Card title="Migration">
    Migrating from existing Express codebase
  </Card>
  <Card title="Maximum Control">
    Need low-level HTTP control
  </Card>
</Cards>

### When to Choose ZyntraJS

<Cards>
  <Card title="Type Safety">
    Want automatic end-to-end type safety
  </Card>
  <Card title="Modern DX">
    Prefer modern TypeScript-first development
  </Card>
  <Card title="Auto Client">
    Need automatic client generation
  </Card>
  <Card title="Built-in Tools">
    Want validation, jobs, telemetry out of the box
  </Card>
</Cards>

---

## ZyntraJS vs Fastify

### Overview

Fastify is the fastest Node.js framework, optimized for performance. ZyntraJS prioritizes developer experience while maintaining excellent performance.

### Feature Comparison

| Feature | ZyntraJS | Fastify |
|---------|------------|---------|
| Performance | âš¡âš¡ Very fast | âš¡âš¡âš¡ Fastest |
| Type Safety | âœ… Automatic inference | âš ï¸ Manual generics |
| Validation | âœ… Zod/Valibot | âœ… JSON Schema |
| Client Generation | âœ… Automatic | âŒ Manual |
| React Hooks | âœ… Built-in | âŒ External |
| Schema Required | âš ï¸ Optional | âœ… Recommended |
| OpenAPI | âœ… Auto-generated | âš ï¸ Via plugin |
| DX | âš¡ Excellent | ğŸŸ¡ Good |
| Ecosystem | ğŸŸ¡ Growing | âš¡ Large |
| Plugin System | âœ… Yes | âš¡âš¡ Very rich |

### Code Comparison

<Tabs items={['ZyntraJS', 'Fastify']}>
  <Tab value="ZyntraJS">
    ```typescript
    // Automatic type inference
    const getUser = zyntra.query({
      name: 'Get User',
      description: 'Retrieve a specific user by ID',
      path: '/users/:id' as const,
      handler: async ({ request, response }) => {
        // âœ… request.params.id is automatically typed
        const user = await db.users.findUnique({ 
          where: { id: request.params.id } 
        });
        
        if (!user) {
          return response.notFound('User not found');
        }
        
        return response.success({ user });
      }
    });
    
    // Client: Automatic hooks
    const { data, isLoading } = client.users.getById.useQuery({
      params: { id: '123' }
    });
    ```
  </Tab>
  
  <Tab value="Fastify">
    ```typescript
    // Manual type definitions
    interface GetUserParams {
      id: string;
    }
    
    interface GetUserReply {
      user: User;
    }
    
    fastify.get<{
      Params: GetUserParams;
      Reply: GetUserReply;
    }>('/users/:id', {
      schema: {
        params: {
          type: 'object',
          properties: {
            id: { type: 'string' }
          }
        },
        response: {
          200: {
            type: 'object',
            properties: {
              user: { type: 'object' }
            }
          }
        }
      }
    }, async (request, reply) => {
      const user = await db.users.findUnique({ 
        where: { id: request.params.id } 
      });
      
      if (!user) {
        return reply.code(404).send({ error: 'User not found' });
      }
      
      return { user };
    });
    
    // Client: Manual fetch
    const response = await fetch('/users/123');
    const data = await response.json() as GetUserReply;
    ```
  </Tab>
</Tabs>

### When to Choose Fastify

<Cards>
  <Card title="Maximum Performance">
    Performance is the absolute top priority
  </Card>
  <Card title="JSON Schema">
    Prefer JSON Schema over Zod
  </Card>
  <Card title="Rich Plugins">
    Need access to Fastify's plugin ecosystem
  </Card>
  <Card title="Low-Level Control">
    Need fine-grained HTTP control
  </Card>
</Cards>

### When to Choose ZyntraJS

<Cards>
  <Card title="Better DX">
    Developer experience matters more than raw speed
  </Card>
  <Card title="Auto Types">
    Want automatic type inference
  </Card>
  <Card title="React Integration">
    Need built-in React hooks
  </Card>
  <Card title="Zod/Valibot">
    Prefer Zod over JSON Schema
  </Card>
</Cards>

---

## Summary

Choose **ZyntraJS** if you want:

- âœ… **End-to-end type safety** without code generation
- âœ… **Framework flexibility** (not locked to Next.js)
- âœ… **Standard HTTP/REST** support
- âœ… **Built-in ecosystem** (jobs, caching, telemetry, bots)
- âœ… **Excellent DX** with automatic client generation
- âœ… **Production-ready** features out of the box

<Callout type="success" title="Ready to Start?">
  ZyntraJS combines the best of all worlds: tRPC's type safety, Express's flexibility, and a rich built-in ecosystem.
  
  [Get Started â†’](/docs/installation)
</Callout>
